---
title: "多重假设检验在食品安全数据中的原理与实操"
author: "lyjlyjn"
date: "2025-11-03"
lang: zh-CN
toc: true
toc-depth: 3
numbersections: true
fontsize: 11pt
geometry: margin=1in
links-as-notes: true
---

# 摘要
本讲义面向食品安全数据分析，系统讲解“多重假设检验”的原理、方法选择、实操流程与报告规范，并给出 R/Python 可直接运行的示例。覆盖微生物计数（CFU）、检出率/阳性率、化学残留浓度（含 <LOD/LOQ 删失）、货架期/生存数据、以及多产品/多污染物的多重比较。

# 1. 为什么需要多重检验校正
- 当同时做 $m$ 个检验、每个检验显著性阈值为 $\alpha$ 时，至少出现一个假阳性的概率（家族错误率 FWER）约为：
  $$\text{FWER} = 1-(1-\alpha)^m$$
  例：$m=20, \alpha=0.05 \Rightarrow \text{FWER}\approx 64\%$。
- 两类主要控制目标：
  - 控 FWER：避免“至少一个假阳性”。严格、保守，适合合规/确证（如是否超标、病原体是否存在）。
  - 控 FDR：允许少量假阳性，控制期望的假阳性比例 $E[V/R]\le q$。功效更高，适合探索/筛查（多污染物、多病原体）。
- 关键概念——“假设族”（family）：一起解读和报告的一组检验（如“所有产品×病原体的两两比较”）。先定义族，再做校正。

# 2. 常见方法及使用原理
## 2.1 控 FWER（严格）
- Bonferroni：阈值 $\alpha/m$（或 p 乘以 m）。简单但保守。基于 Boole 不等式。
- Šidák：阈值 $1-(1-\alpha)^{1/m}$，假设独立，略宽于 Bonferroni。
- Holm（step-down）：排序后依次比较 $p_{(i)}\le \alpha/(m-i+1)$；一旦不显著即停止。通常比 Bonferroni 有力。
- Hochberg（step-up）：在独立或正相关（PRDS）下比 Holm 更有力。
- 多均值比较（ANOVA 事后）：
  - Dunnett：多处理 vs 单一对照，控全局 I 类错；对照设计首选。
  - Tukey HSD：所有两两比较，方差齐假设下提供“同时性”置信区间。
  - Games–Howell：两两比较、方差不齐且样本不等的稳健替代。
- Westfall–Young 置换：利用重采样估计最小 p 的分布，考虑依赖结构，更有力但计算量大。

## 2.2 控 FDR（更有力）
- Benjamini–Hochberg（BH，step-up）：找最大 k 满足 $p_{(k)}\le (k/m)\cdot q$，拒绝前 k 个。独立或 PRDS 下严格控制，实践中鲁棒。
- Benjamini–Yekutieli（BY）：对任意依赖严格，阈值更保守（乘以调和级数因子 $c(m)=\sum_{i=1}^m 1/i$）。
- Storey q-value：估计 $\pi_0$（真零假设比例），通常较 BH 更有力。

## 2.3 分层/序贯策略（确证研究常用）
- Gatekeeping/层级检验：先测主要终点，显著后再开放次要终点；在整体控 FWER 的同时体现优先级。
- 闭包法/α 回收：在组合与依赖结构下提升功效，但实现和报告更复杂。

# 3. 方法选择决策（速查）
- 目标与场景：
  - 合规/确证（严控假阳性）：Holm 优先；对照 vs 多处理用 Dunnett；两两比较用 Tukey（方差不齐则 Games–Howell）。
  - 探索/筛查（多分析物/多病原体/多指标）：BH（FDR）；强相关顾虑时用 BY 或置换。
- 数据结构：
  - 组间均值：先检分布与方差齐性；不满足用 Welch 或稳健/非参；事后选择相应多重方法。
  - 比例/阳性率：Fisher/卡方或 Logistic 回归；多指标并行 → FDR。
  - 计数（CFU）：常过度离散 → 负二项（NB）或变换后检验；多比较结合 FWER/FDR。
  - 残留（含 <LOD/LOQ）：优先删失方法（NADA/Tobit/生存回归），跨分析物 → FDR 或 Holm。
  - 生存/货架期：KM/log-rank 或 Cox；多组两两比较 → FDR 或 Holm。

# 4. 食品安全常见场景与配套方法
## 4.1 微生物计数（CFU/g）
- 右偏、过度离散常见。两组/多组比较可用 NB 回归；或 log10 变换后做 t/Welch/非参。
- 分层（厂/批次）→ 混合效应（随机截距）。
- 事后比较：对照设计首选 Dunnett；两两比较 Tukey；方差不齐用 Games–Howell。
- 多指标并行（多菌种/多工艺）→ FDR（BH）。

## 4.2 检出率/阳性率
- 两组比较：Fisher 精确/卡方；可扩展为 Logistic 回归加入协变量。
- 跨多病原体、多产品并行 → FDR；监管严控 → Holm/Bonferroni。

## 4.3 化学残留浓度与 LOD/LOQ（左删失）
- 避免简单代入 0 或 LOD/2；用删失方法（R: NADA/NADA2 的 ROS/K-M；Tobit/参数生存回归）。
- 组间比较可在删失回归框架内进行；多分析物并行 → FDR（BH/Storey）。

## 4.4 货架期/生存数据
- KM 曲线 + log-rank；含协变量用 Cox。
- 多组两两比较需多重校正（BH 或 Holm）。

## 4.5 重复测量/时间序列
- 重复测量 ANOVA 或线性混合模型；违背球形性时混合模型更稳健。
- 抽样设计（分层/整群）→ 需考虑设计效应（R: survey 包）。

# 5. 报告与解释
- 同时报告：原始 p、校正后 p（或 q）、效应量与 95% CI、所用方法与前提。
- 效应量示例：均值差/Cohen’s d、OR、RR、HR、几何均值比 GMR、回归系数。
- 同时性区间：Tukey/Dunnett 提供“同时覆盖率”的置信区间。
- 事前设定：明确假设族、主要/次要终点、校正策略，避免事后选择性报告。

# 6. 小例子：BH vs Holm
- 原始 p：0.001, 0.02, 0.04, 0.20（m=4）
- Holm（FWER，升序阈值 0.05/4, 0.05/3, 0.05/2, 0.05）：
  - 0.001 ≤ 0.0125 → 拒绝；0.02 ≤ 0.0167 不成立 → 终止。仅第一个显著。
- BH（FDR，q=0.05，阈值 (k/m)q：0.0125, 0.025, 0.0375, 0.05）：
  - 最大 k 满足 p(k) ≤ 阈值：k=2 → 前两个（0.001 与 0.02）显著。

# 7. 实操流程（Checklist）
1. 定义假设族与控制目标（FWER/FDR）
2. EDA 与前提检查（分布、方差齐性、删失比例、分层/批次）
3. 选检验/模型（t/Welch/ANOVA/非参；Logistic/NB；删失法；Cox）
4. 计算原始 p 或估计效应与标准误
5. 多重校正（Holm/BH/BY/…；必要时分族分别校正）
6. 可视化与报告（火山图、森林图、KM；报告 p_adj/q 与 CI）
7. 复现记录（脚本、随机种子、版本、分析计划）

# 8. R 代码清单（可直接运行）
```r
# 多重校正
p <- c(0.001, 0.02, 0.04, 0.20)
p.adjust(p, method="holm")   # FWER
p.adjust(p, method="BH")     # FDR

# Dunnett（对照 vs 多处理）
# install.packages(c("emmeans","multcomp"))
library(emmeans); library(multcomp)
fit <- aov(y ~ group, data=df)                 # 或线性/广义线性模型
emm <- emmeans(fit, ~ group)
summary(contrast(emm, method="trt.vs.ctrl", ref="Control", adjust="dunnett"))

# Games–Howell（方差不齐的两两比较）
# install.packages("userfriendlyscience")
userfriendlyscience::oneway(y ~ group, data=df, posthoc="games-howell")

# 阳性率（按病原体分族做 FDR）
library(dplyr); library(purrr)
res <- df %>% group_by(pathogen, product) %>%
  summarise(p_raw = binom.test(sum(positive), n(), alternative="two.sided")$p.value, .groups="drop")
res <- res %>% group_by(pathogen) %>%
  mutate(p_adj = p.adjust(p_raw, "BH")) %>% ungroup()

# 计数数据：负二项 + 事后对比（如需对照）
# install.packages(c("MASS","lme4","lmerTest"))
library(MASS); library(lme4); library(lmerTest)
# 简化版（无随机效应）
fit_nb <- MASS::glm.nb(CFU ~ group, data = df_count)
emm <- emmeans(fit_nb, ~ group)
contrast(emm, method="trt.vs.ctrl", ref="Control", adjust="holm")

# 残留 <LOD/LOQ：删失处理 + 组间比较
# install.packages("NADA2")
library(NADA2)
# df_residue: conc, group, censored(1=<LOD,0=检测到)
ros_vals <- ros(obs = df_residue$conc, censored = df_residue$censored)
df_residue$conc_ros <- ros_vals$modeled
by_analyte <- df_residue |>  
  dplyr::group_by(Analyte) |>  
  dplyr::summarise(p_raw = wilcox.test(conc_ros ~ group, exact=FALSE)$p.value, .groups="drop")
by_analyte$p_adj <- p.adjust(by_analyte$p_raw, method="BH")

# 货架期：KM + 两两 log-rank + BH
# install.packages(c("survival","survminer"))
library(survival); library(survminer)
fit_km <- survfit(Surv(time, status) ~ treatment, data = df_surv)
ggsurvplot(fit_km, pval=FALSE, conf.int=TRUE)
lvls <- levels(factor(df_surv$treatment))
pairs <- combn(lvls, 2, simplify = FALSE)
pvals <- vapply(pairs, function(pp){
  d <- subset(df_surv, treatment %in% pp)
  sd <- survdiff(Surv(time,status) ~ treatment, data=d)
  1 - pchisq(sd$chisq, df=1)
}, numeric(1))
p.adjust(pvals, method="BH")
```

# 9. Python 代码清单（可直接运行）
```python
import numpy as np
import pandas as pd
from scipy import stats
import statsmodels.api as sm
from statsmodels.stats.multitest import multipletests
from itertools import combinations

# 多重校正
p = np.array([0.001, 0.02, 0.04, 0.20])
rej_holm, p_holm, _, _ = multipletests(p, method='holm')     # FWER
rej_bh,   p_bh,   _, _ = multipletests(p, method='fdr_bh')   # FDR

# 阳性率（按病原体分族 FDR）
# df_bin: columns ['product','pathogen','positive']
def binom_p(k, n):
    return stats.binomtest(k, n).pvalue
res = (df_bin.groupby(['product','pathogen'])['positive']
       .agg(['sum','count']).reset_index()
       .rename(columns={'sum':'pos','count':'n'}))
res['p_raw'] = res.apply(lambda r: binom_p(r.pos, r.n), axis=1)
res['p_adj'] = (res.groupby('pathogen')['p_raw']
                .transform(lambda x: multipletests(x, method='fdr_bh')[1]))

# 计数数据：负二项 + 事后（Holm/FDR）
# df_count: ['CFU','group']
X = pd.get_dummies(df_count['group'], drop_first=True)
X = sm.add_constant(X)
model_nb = sm.GLM(df_count['CFU'], X, family=sm.families.NegativeBinomial())
res_nb = model_nb.fit()
pvals = res_nb.pvalues.drop('const', errors='ignore').to_numpy()
rej, p_adj, _, _ = multipletests(pvals, method='holm')

# 两两比较（Tukey/GH 可用 scikit-posthocs 或 pingouin）
# 这里演示基于线性模型的成对对比 + FDR
import statsmodels.formula.api as smf
m = smf.ols("y ~ C(group)", data=df).fit()
groups = df['group'].unique().tolist()
pairs = list(combinations(groups, 2))
pvals = []
for a,b in pairs:
    # 构造对比：a - b
    contrast = [0] + [1 if g==a else -1 if g==b else 0 for g in groups[1:]]
    pvals.append(float(m.t_test(contrast).pvalue))
p_adj = multipletests(pvals, method='fdr_bh')[1]

# 货架期：两两 log-rank + BH
from lifelines import statistics as lf_stats
pairs = [(groups[i], groups[j]) for i in range(len(groups)) for j in range(i+1,len(groups))]
pvals = []
for g1, g2 in pairs:
    d1 = df_surv[df_surv['treatment']==g1]
    d2 = df_surv[df_surv['treatment']==g2]
    res_lr = lf_stats.logrank_test(d1['time'], d2['time'], d1['status'], d2['status'])
    pvals.append(res_lr.p_value)
p_adj = multipletests(pvals, method='fdr_bh')[1]
```